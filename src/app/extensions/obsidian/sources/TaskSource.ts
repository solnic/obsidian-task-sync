/**
 * ObsidianTaskSource - Pure data source for Obsidian vault tasks
 *
 * Responsibilities:
 * - Scan vault for task files
 * - Parse task files into Task entities
 * - Watch for file changes and notify callbacks
 * - NO store manipulation - just pure data fetching
 *
 * This source provides tasks from the Obsidian vault by scanning the tasks folder
 * and parsing markdown files with task front-matter.
 */

import type { App } from "obsidian";
import type { DataSource } from "../../../sources/DataSource";
import type { Task } from "../../../core/entities";
import type { TaskSyncSettings } from "../../../types/settings";
import { ObsidianTaskOperations } from "../operations/TaskOperations";
import { ObsidianTaskReconciler } from "../../../core/TaskReconciler";

/**
 * ObsidianTaskSource class
 *
 * Implements DataSource<Task> for Obsidian vault tasks
 */
export class ObsidianTaskSource implements DataSource<Task> {
  readonly id = "obsidian";
  readonly name = "Obsidian Vault";
  readonly reconciler = new ObsidianTaskReconciler();

  private taskOperations: ObsidianTaskOperations;

  constructor(private app: App, private settings: TaskSyncSettings) {
    this.taskOperations = new ObsidianTaskOperations(app, settings);
  }

  /**
   * Load initial data by scanning the vault for task files
   *
   * @returns Promise resolving to array of tasks with IDs
   *
   * Note: Tasks are returned with IDs generated by buildEntity.
   * The store reducer will use the reconciler to match tasks by filePath
   * and preserve existing IDs when tasks are re-scanned.
   */
  async loadInitialData(): Promise<readonly Task[]> {
    console.log("[ObsidianTaskSource] Loading initial data...");

    // Scan existing task files in the vault
    // scanExistingTasks returns Task[] with IDs generated by buildEntity
    const tasks = await this.taskOperations.scanExistingTasks();

    console.log(`[ObsidianTaskSource] Loaded ${tasks.length} tasks from vault`);

    return tasks;
  }

  /**
   * Refresh data by re-scanning the vault
   *
   * @returns Promise resolving to array of tasks with IDs
   */
  async refresh(): Promise<readonly Task[]> {
    console.log("[ObsidianTaskSource] Refreshing data...");

    // Re-scan vault and return fresh data
    // This is the same as loadInitialData - we just re-scan everything
    return this.loadInitialData();
  }

  /**
   * Watch for file changes in the vault
   *
   * IMPORTANT: This should NOT be used. ObsidianExtension.setupVaultEventListeners()
   * already handles all file watching using metadataCache.on("changed") with cache parameter.
   *
   * This method exists only to satisfy the DataSource interface but returns a no-op cleanup.
   *
   * Why we don't use this:
   * 1. ObsidianExtension already sets up proper event listeners with cache parameter
   * 2. Using vault.on("create") causes duplicate processing when files are created
   * 3. metadataCache.on("changed") without cache parameter requires waitForMetadataCache
   *
   * @param _callback - Ignored callback (not used)
   * @returns No-op cleanup function
   */
  watch(_callback: (tasks: readonly Task[]) => void): () => void {
    console.log(
      "[ObsidianTaskSource] watch() called but not setting up listeners - ObsidianExtension handles this"
    );

    // Return no-op cleanup function
    return () => {
      console.log("[ObsidianTaskSource] No watchers to clean up");
    };
  }
}
