/**
 * ObsidianTaskSource - Pure data source for Obsidian vault tasks
 *
 * Responsibilities:
 * - Scan vault for task files
 * - Parse task files into Task entities
 * - Watch for file changes and notify callbacks
 * - NO store manipulation - just pure data fetching
 *
 * This source provides tasks from the Obsidian vault by scanning the tasks folder
 * and parsing markdown files with task front-matter.
 */

import type { App } from "obsidian";
import type {
  DataSource,
  DataSourceWatchCallbacks,
} from "../../../sources/DataSource";
import type { Task } from "../../../core/entities";
import type { TaskSyncSettings } from "../../../types/settings";
import { ObsidianTaskOperations } from "../operations/TaskOperations";

import { get } from "svelte/store";
import { taskStore } from "../../../stores/taskStore";
import type { ObsidianExtension } from "../ObsidianExtension";

/**
 * ObsidianTaskSource class
 *
 * Implements DataSource<Task> for Obsidian vault tasks
 */
export class ObsidianTaskSource implements DataSource<Task> {
  readonly id = "obsidian";
  readonly name = "Obsidian Vault";

  private taskOperations: ObsidianTaskOperations;
  private extension: ObsidianExtension;

  constructor(
    private app: App,
    private settings: TaskSyncSettings,
    extension: ObsidianExtension
  ) {
    this.taskOperations = new ObsidianTaskOperations(app, settings);
    this.extension = extension;
  }

  /**
   * Load initial data by scanning the vault for task files
   *
   * @returns Promise resolving to array of tasks with IDs
   *
   * Note: Tasks are returned with IDs generated by buildEntity.
   *
   * Only returns tasks that are owned by the Obsidian extension (source.extension = "obsidian").
   * Tasks owned by other extensions (e.g., GitHub) are ignored even if they have Obsidian files.
   */
  async loadInitialData(): Promise<readonly Task[]> {
    console.log("[ObsidianTaskSource] Loading initial data...");

    // Scan existing task files in the vault
    // scanExistingTasks returns Task[] with IDs generated by buildEntity
    const allTasks = await this.taskOperations.scanExistingTasks();

    // Return all scanned tasks - the reducer will handle merging correctly
    // No need to filter by source.extension here
    console.log(
      `[ObsidianTaskSource] Scanned ${allTasks.length} tasks from vault`
    );

    // Update the extension's entity store with scanned tasks
    // scanExistingTasks returns readonly array, spread to convert to mutable
    this.extension.updateEntityStore([...allTasks]);
    console.log(
      `[ObsidianTaskSource] Updated extension entity store with ${allTasks.length} tasks`
    );

    return allTasks;
  }

  /**
   * Refresh data by re-scanning the vault and ensuring file integrity
   *
   * CRITICAL: This method scans FIRST, then updates files. This order is important because:
   * 1. Scanning with existing tasks in the store preserves source.extension for GitHub tasks
   * 2. After scanning, we update/recreate files based on the scanned tasks
   *
   * @returns Promise resolving to array of tasks with IDs
   */
  async refresh(): Promise<readonly Task[]> {
    console.log("[ObsidianTaskSource] Refreshing data...");

    // Step 1: Re-scan the vault FIRST
    // This preserves source.extension by looking up existing tasks in the store
    const scannedTasks = await this.loadInitialData();

    // Step 2: Now ensure files exist and have correct properties
    // Get all tasks from the store that should have Obsidian files
    const currentTasks = get(taskStore).tasks;
    const tasksWithObsidianKeys = currentTasks.filter(
      (task) => task.source.keys.obsidian
    );

    console.log(
      `[ObsidianTaskSource] Ensuring file integrity for ${tasksWithObsidianKeys.length} tasks with Obsidian files`
    );

    // Ensure files exist and have correct properties
    for (const task of tasksWithObsidianKeys) {
      const filePath = task.source.keys.obsidian;
      const file = this.app.vault.getAbstractFileByPath(filePath);

      if (!file) {
        // File is missing - recreate it
        console.log(
          `[ObsidianTaskSource] Recreating missing file for task: ${task.title}`
        );
        try {
          await this.taskOperations.createNote(task);
        } catch (error) {
          console.error(
            `[ObsidianTaskSource] Failed to recreate file for task ${task.title}:`,
            error
          );
        }
      } else {
        // File exists - update it to ensure correct properties
        console.log(
          `[ObsidianTaskSource] Updating file properties for task: ${task.title}`
        );
        try {
          await this.taskOperations.updateNote(task);
        } catch (error) {
          console.error(
            `[ObsidianTaskSource] Failed to update file for task ${task.title}:`,
            error
          );
        }
      }
    }

    return scannedTasks;
  }

  /**
   * Watch for file changes in the vault
   *
   * Uses incremental updates (onItemChanged, onItemDeleted) for efficiency.
   * Only parses the changed file using the cache parameter from metadataCache.on("changed").
   *
   * IMPORTANT: Does NOT listen to vault.on("create") because that fires when UI creates
   * tasks, causing duplicate processing. The metadataCache.on("changed") event fires for
   * both new files and modified files.
   *
   * @param callbacks - Callbacks for different types of changes
   * @returns Cleanup function to stop watching
   */
  watch(callbacks: DataSourceWatchCallbacks<Task>): () => void {
    console.log("[ObsidianTaskSource] Setting up file watchers...");

    const tasksFolder = this.settings.tasksFolder;

    // Helper to check if a file is in the tasks folder
    const isTaskFile = (file: any): boolean => {
      return file.path.startsWith(tasksFolder + "/");
    };

    // Listen for file modifications (front-matter changes)
    // Use metadataCache.on("changed") which provides cache parameter
    const onModify = this.app.metadataCache.on(
      "changed",
      async (file, _data, cache) => {
        if (isTaskFile(file)) {
          console.log(`[ObsidianTaskSource] Task file changed: ${file.path}`);

          try {
            // Parse only the changed file using the cache parameter
            const taskData = await this.taskOperations.parseFileToTaskData(
              file,
              cache
            );

            // Only notify if parsing succeeded (taskData is not null)
            if (taskData && callbacks.onItemChanged) {
              // Update the extension's entity store with the changed task
              this.updateEntityStoreWithTask(taskData);

              callbacks.onItemChanged(taskData);
            }
          } catch (error) {
            console.warn(
              `[ObsidianTaskSource] Skipping task file ${file.path}`,
              error
            );
          }
        }
      }
    );

    // Listen for file deletions
    const onDelete = this.app.vault.on("delete", async (file) => {
      if (isTaskFile(file)) {
        console.log(`[ObsidianTaskSource] Task file deleted: ${file.path}`);

        if (callbacks.onItemDeleted) {
          // Find the task by Obsidian key to get its ID
          const currentState = get(taskStore);
          const existingTask = currentState.tasks.find(
            (t) => t.source.keys.obsidian === file.path
          );

          if (existingTask) {
            // Remove from extension's entity store
            this.removeTaskFromEntityStore(existingTask.id);

            // Notify about the deleted item
            callbacks.onItemDeleted(existingTask.id);
          }
        }
      }
    });

    // Return cleanup function
    return () => {
      console.log("[ObsidianTaskSource] Cleaning up file watchers...");
      this.app.metadataCache.offref(onModify);
      this.app.vault.offref(onDelete);
    };
  }

  /**
   * Update the extension's entity store with a single changed task
   */
  private updateEntityStoreWithTask(changedTask: Task): void {
    const currentTasks = get(this.extension.getEntityStore()) as Task[];
    const existingIndex = currentTasks.findIndex(
      (t: Task) => t.id === changedTask.id
    );

    if (existingIndex >= 0) {
      // Update existing task
      const updatedTasks = [...currentTasks];
      updatedTasks[existingIndex] = changedTask;
      this.extension.updateEntityStore(updatedTasks);
    } else {
      // Add new task
      this.extension.updateEntityStore([...currentTasks, changedTask]);
    }

    console.log(
      `[ObsidianTaskSource] Updated entity store with task: ${changedTask.title}`
    );
  }

  /**
   * Remove a task from the extension's entity store
   */
  private removeTaskFromEntityStore(taskId: string): void {
    const currentTasks = get(this.extension.getEntityStore()) as Task[];
    const updatedTasks = currentTasks.filter((t: Task) => t.id !== taskId);
    this.extension.updateEntityStore(updatedTasks);

    console.log(
      `[ObsidianTaskSource] Removed task ${taskId} from entity store`
    );
  }
}
