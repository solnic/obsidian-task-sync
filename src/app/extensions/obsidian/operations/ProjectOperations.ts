/**
 * Obsidian Project Operations
 * Reactive note manager that responds to project domain events by managing corresponding Obsidian notes
 */

import { App, TFile } from "obsidian";
import { get } from "svelte/store";
import { Project } from "../../../core/entities";
import { ObsidianEntityOperations } from "./EntityOperations";
import { ObsidianBaseManager } from "../utils/BaseManager";
import type { TaskSyncSettings } from "../../../types/settings";
import { PROPERTY_REGISTRY } from "../utils/PropertyRegistry";
import { projectStore } from "../../../stores/projectStore";
import { Projects } from "../../../entities/Projects";
import { EntitiesOperations } from "../../../core/entities-base";

export class ObsidianProjectOperations extends ObsidianEntityOperations<Project> {
  private projectOperations: EntitiesOperations;

  constructor(
    app: App,
    private settings: TaskSyncSettings,
    private baseManager?: ObsidianBaseManager
  ) {
    super(app, settings.projectsFolder);
    this.projectOperations = new Projects.Operations(settings);
  }

  /**
   * Scan the projects folder and return all existing project files as Project entities
   * Projects are returned with IDs generated by buildEntity
   * This is used during extension initialization to populate the canonical store
   */
  async scanExistingProjects(): Promise<readonly Project[]> {
    console.log(`Scanning projects folder: ${this.folder}`);
    const folder = this.app.vault.getFolderByPath(this.folder);

    if (!folder) {
      console.warn(
        `Projects folder '${this.folder}' does not exist, returning empty array`
      );
      return [];
    }

    const projectFiles = folder.children
      .filter((child) => child instanceof TFile && child.extension === "md")
      .map((child) => child as TFile);

    console.log(
      `Found ${projectFiles.length} .md files in projects folder:`,
      projectFiles.map((f) => f.path)
    );

    const projects: Project[] = [];

    // Get existing projects once to avoid N+1 pattern
    const existingProjects = get(projectStore).projects;

    for (const file of projectFiles) {
      try {
        console.log(`Parsing project file: ${file.path}`);
        const projectData = await this.parseFileToProjectData(
          file,
          undefined,
          existingProjects
        );
        if (projectData) {
          console.log(`Successfully parsed project: ${projectData.name}`);
          projects.push(projectData);
        } else {
          console.log(`File ${file.path} was not a valid project`);
        }
      } catch (error) {
        console.error(`Failed to parse project file ${file.path}:`, error);
      }
    }

    console.log(`Scan complete. Found ${projects.length} valid projects`);
    return projects;
  }

  /**
   * Parse a project file into a Project entity
   * @param file - The file to parse
   * @param cache - Optional metadata cache from the changed event
   * @param existingProjects - Optional array of existing projects to preserve IDs
   * @returns Project data with ID, or null if the file is not a valid project file
   */
  async parseFileToProjectData(
    file: TFile,
    cache?: any,
    existingProjects?: readonly Project[]
  ): Promise<Project | null> {
    // If cache is provided (from changed event), use it directly
    // Otherwise get it from metadata cache (synchronous)
    const fileCache = cache || this.app.metadataCache.getFileCache(file);
    const frontMatter = fileCache?.frontmatter;

    // If no frontmatter available, skip this file
    if (!frontMatter) {
      return null;
    }

    // Check if this is a project file
    if (frontMatter.Type !== "Project") {
      return null;
    }

    // Check if we have an existing project with this file path
    const existingProject = existingProjects?.find(
      (p) => p.source.keys.obsidian === file.path
    );

    // Build project data
    const projectData: Omit<Project, "id" | "createdAt" | "updatedAt"> = {
      name: frontMatter.Name || file.basename,
      description: frontMatter.Description || "",
      areas: Array.isArray(frontMatter.Areas) ? frontMatter.Areas : [],
      tags: Array.isArray(frontMatter.Tags) ? frontMatter.Tags : [],
      source: {
        extension: "obsidian",
        keys: {
          obsidian: file.path,
        },
      },
    };

    // Use buildEntity to generate proper ID and timestamps
    // If we have an existing project, preserve its ID
    if (existingProject) {
      return {
        ...this.projectOperations.buildEntity(projectData),
        id: existingProject.id,
        createdAt: existingProject.createdAt,
      } as Project;
    }

    return this.projectOperations.buildEntity(projectData) as Project;
  }

  // Implement abstract method to get entity display name for file naming
  protected getEntityDisplayName(project: Project): string {
    return project.name;
  }

  // Implement abstract methods for project-specific behavior
  protected generateFrontMatter(project: Project): Record<string, any> {
    return {
      [PROPERTY_REGISTRY.NAME.name]: project.name, // Use property name from registry
      [PROPERTY_REGISTRY.TYPE.name]: "Project", // Always "Project" for project entities
      [PROPERTY_REGISTRY.AREAS.name]:
        project.areas && project.areas.length > 0 ? project.areas : undefined,
      [PROPERTY_REGISTRY.TAGS.name]:
        project.tags && project.tags.length > 0 ? project.tags : undefined,
    };
  }

  protected getEntityType(): string {
    return "Project";
  }

  /**
   * Override createNote to use parent implementation
   * TypeNote integration is disabled for entity notes because:
   * 1. Entity notes need description in content, not front-matter
   * 2. ObsidianEntityOperations already handles front-matter correctly
   */
  async createNote(project: Project): Promise<string> {
    // Always use the parent implementation which handles front-matter correctly
    const filePath = await super.createNote(project);

    // Then generate the base file if enabled
    await this.generateBaseForProject(project);

    return filePath;
  }

  /**
   * Override updateNote to include base regeneration
   * This ensures bases stay in sync when projects are updated
   */
  async updateNote(project: Project): Promise<void> {
    // First update the note using parent implementation
    await super.updateNote(project);

    // Then regenerate the base file if enabled
    await this.generateBaseForProject(project);
  }

  /**
   * Update settings reference
   * Should be called when settings change
   */
  updateSettings(newSettings: TaskSyncSettings): void {
    this.settings = newSettings;
  }

  /**
   * Generate base file for a project
   * Only generates if base manager is available, bases are enabled, and auto-sync is on
   */
  private async generateBaseForProject(project: Project): Promise<void> {
    // Check if base generation is enabled and configured
    if (
      !this.baseManager ||
      !this.settings?.projectBasesEnabled ||
      !this.settings?.autoSyncAreaProjectBases
    ) {
      return;
    }

    // Check if project has the required filePath
    const filePath = project.source.keys.obsidian;
    if (!filePath) {
      console.warn(
        `Cannot generate base for project "${project.name}": missing Obsidian file path`
      );
      return;
    }

    try {
      const projectInfo = {
        name: project.name,
        path: filePath,
        type: "project" as const,
      };

      console.log(`Generating base for project: ${project.name}`);
      await this.baseManager.createOrUpdateProjectBase(projectInfo);
    } catch (error) {
      console.error(
        `Failed to generate base for project "${project.name}":`,
        error
      );
    }
  }
}
